# HTTP와 HTTPS

HTTP(Hyper Text Transfer Protocol)란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다.

### **[ HTTP의 구조 ]**

HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성된다.

![image](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F53157e87-bf26-4ab7-90fd-3e5d28627ea7%2FUntitled.png?table=block&id=36239cbc-09f0-41ca-98dd-2798e6c487c9&spaceId=552fe0dc-fdb3-4c62-979e-df2a2e235613&width=2000&userId=a09a1ca3-4214-4905-a7a2-172e60f8cd39&cache=v2)

### **[ HTTPS(Hyper Text Transfer Protocol Secure)란? ]**

HyperText Transfer Protocol over Secure Socket Layer, HTTP over TLS, HTTP over SSL, HTTP Secure 등으로 불리는 HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜이다. HTTPS는 HTTP와 다르게 443번 포트를 사용하며, 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원하고 있다.

## 무상태 프로토콜(Stateless)

HTTP에서는 서버가 **클라이언트의 상태를 보존하지 않는다**.

따라서 응답과 요청이 독립적이다.

- 장점 : **서버 확장성**이 높다.무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능하다.(스케일 아웃)
- 단점 : 클라이언트가 추가 데이터를 전송해야 한다.
    
    > 무상태(Stateless)의 한계
    > 
    > 
    > 로그인과 같이 유저의 상태를 유지해야하는 서비스라면, **브라우저 쿠키, 서버 세션, 토큰** 등을 이용해 상태를 유지해야 한다.
    > 

---

## 3. 비연결성(Connectionless)

### Connection Oriented(연결을 유지하는 모델)

TCP/IP는 기본적으로 연결을 유지한다.

연결을 유지하는 모델에서는 클라이언트가 요청을 보내지 않더라도 계속 연결을 유지해야 한다.

⇒이 경우, 연결을 유지하는 서버의 자원이 계속 소모된다.

![image](https://velog.velcdn.com/images/wlwl99/post/7a4c3335-ba69-4589-b77b-cf35dbd83775/image.png)

### Connectionless(연결을 유지하지 않는 모델)

비연결성을 가지는 HTTP에서는 실제로 요청을 주고받을 때만 연결을 유지하고 **응답을 주고 나면 TCP/IP 연결을 끊는다**.

⇒이를 통해 최소한의 자원으로 서버를 유지할 수 있다.

![image](https://velog.velcdn.com/images/wlwl99/post/614190c0-9a42-4aee-8ca4-401dbd35fd1a/image.png)

### HTTP의 비연결성

- HTTP 1.0을 기준으로, HTTP는 기본적으로 **연결을 유지하지 않는 모델**이다.
    - 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
    - 1시간 동안 수천 명이 서비스를 사용해도 실제 서버에서 처리하는 요청은 수십 개 이하로 매우 작다. (ex. 웹 브라우저에서 연속해서 검색 버튼을 누르지 않기 때문)
- 비연결성의 특징은 트래픽이 많지 않고, 빠른 응답을 제공할 수 있는 경우 효율적으로 작동한다.
- 하지만 트래픽이 많고, 큰 규모의 서비스를 운영할 때 비연결성은 한계를 보인다.

### HTTP 1.0 - 비연결성의 한계

- TCP/IP 연결을 새로 맺어야하므로 3 way handshake 시간이 추가된다.
- 웹 브라우저로 사이트를 요청하면 HTML, CSS, JavaScript, 추가 이미지 등 수많은 자원이 함께 다운로드되는데, 이러한 자원들을 각각 보낼 때마다 연결을 끊고 다시 연결하고를 반복하는 것은 매우 비효율적이다.
    
    ![image](https://velog.velcdn.com/images/wlwl99/post/fb440875-985f-4590-befc-328fffc066c1/image.png)
    

HTTP 1.0 에서는 **각각의 자원을 다운로드하기 위해 연결과 종료를 반복**해야 했다.

(연결 ~ 종료까지가 새로운 TCP/IP 연결이다.)

> ⇒ HTTP 1.1 에서 HTTP 지속 연결(Persistant Connections)이 가능해지며, 위의 문제들이 해결되었다.
> 

### HTTP 1.1 - 지속 연결

![image](https://velog.velcdn.com/images/wlwl99/post/88e2f97d-86bf-4909-a0ea-a7f011f49d31/image.png)

HTTP 지속 연결에서는 연결이 이루어지고 난 뒤 각각의 자원들을 요청하고, **모든 자원에 대한 응답이 돌아온 후에 연결을 종료**한다.

이밖에도 파이프라이닝, 멀티플렉싱 등 다양한 연결 방식이 있다.

## HTTP 0.9

> GET /mypage.html
> 

```html
<HTML>
A very simple HTML pagge
</HTML>
```

요청은 단일 라인이며 **GET 메소드가 유일**하다. 응답 역시 오로지 파일 내용 자체로 구성된다. 헤더는 없었으며 오직 HTML 파일만 전송가능했다. 상태와 오류 코드도 없었다. 문제가 발생한 경우 HTML 파일이 사람이 처리할 수 있도록, 해당 파일 내부에 문제에 대한 설명과 함께 되돌려 보내졌다.

## HTTP 1.0

> GET /mypage.html HTTP/1.0
> 
> 
> User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)
> 

> 200 OK
> 
> 
> Date: Tue, 15 Nov 1994 08:12:31 GMT
> 
> Server: CERN/3.0 libwww/2.17
> 
> **Content-Type: text/html**
> 
> ```
> <HTML>
> A page with an image
>   <IMG SRC="/myimage.gif">
> </HTML>
> ```
> 

**0.9를 많이 확장**하였다. 헤더가 생기고 버전 정보, 상태 코드, 내용의 타입 등 메타 데이터를 전송할 수 있게 되었다.

다만 한 요청에 한 응답을 완료하면 연결을 종료하기에 **매번 새로운 연결을 맺느라 성능 저하**가 있었다.

## HTTP 1.1

### Persistent Connection

1.0의 연결 문제를 극복하기 위하여 **연결을 닫지 않는 방식**을 도입하게 되었다. 연결을 새로 맺는 과정이 없는 많큼 성능 개선이 있었다.

### Pipelining

pipelining은 processor에서 fetch-decode-execute에서 알 수 있듯, task를 처리하기 위한 연속된 명령들은 각자 자신 뒤에 있는 명령들이 끝나는 것을 기다리지 않고 새로운 task를 처리하는 것이다.

클라이언트 입장에서 한 요청을 보내고 **다음 응답이 오는 것을 기다리지 않고 계속해서 다음 요청을 서버로 보내는 것**이다. 그리고 연속해서 보낸 요청에 대하여 순차적으로 응답을 받는 것이다. 요청마다 응답을 받은 후 새로운 요청을 보내는 것에 비하여 지연 시간을 줄일 수 있었다.

### 👎Head Of Line Blocking

문제는 앞의 요청에 대한 응답이 느리면 연속해서 요청을 보냈어도 그 뒤 응답들은 앞의 응답이 처리 될 때까지 대기하는 문제가 있다.

### 👎Header 의 중복

요청에 대한 헤더가 거의 차이가 없음에도 중복된 헤더를 계속 보내고 있어 네트워크 자원의 소비가 크다.

## HTTP 2.0

Http 1.1의 성능 향상에 집중하였다.

### 메시지 전송 방식의 변화

바이너리 프레이밍 계층을 사용하여 파싱과 전송 속도의 이점을 얻었다. 바이너리이기에 오류 발생 가능성도 줄였다.

### Multiplex streaming

TCP 커넥션 안에 stream들을 두어 바이너리 프레임들을 stream을 통하여 전송하도록 하였다. pipe와는 다르게 양방향 데이터 흐름이 가능하고, 스트림에는 각자 **고유 식별자**와 **우선순위 정보**가 있다.

**Http 메시지는 하나 이상의 프레임**으로 구성되어 있다. 프레임을 전달받은 쪽에서 스트림 식별자를 통하여 **프레임을 재조립하여 메시지를 확인**한다. 이를 통하여 1.1의 HOLB문제를 해결하였다.

### Server Push

클라이언트가 요청하지 않은 정보를 서버가 요청할 것을 예측하여 미리 클라이언트로 보내준다.

### Header Compression

1.1으의 헤더의 중복을 해결하였다. 헤더간의 중복을 찾아서 **중복된 데이터는 인덱스**만 사용하고, **중복되지 않은 데이터는 허프만 인코딩**을 사용하여 보낸다.

![image](https://velog.velcdn.com/images/wlwl99/post/7a9091fd-a9f8-47a8-9e28-3e2a4e953a00/image.png)

### **[ 대칭키 암호화와 비대칭키 암호화 ]**

HTTPS는 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용하고 있다. 각각의 암호화 방식은 다음과 같다.

- 대칭키 암호화
    - 클라이언트와 서버가 동일한 키를 사용해 암호화/복호화를 진행함
    - 키가 노출되면 매우 위험하지만 연산 속도가 빠름
- 비대칭키 암호화
    - 1개의 쌍으로 구성된 공개키와 개인키를 암호화/복호화 하는데 사용함
    - 키가 노출되어도 비교적 안전하지만 연산 속도가 느림
    
    비대칭키 암호화는 공개키/개인키 암호화 방식을 이용해 데이터를 암호화하고 있다. 공개키와 개인키는 서로를 위한 1쌍의 키이다.
    
    - 공개키: 모두에게 공개가능한 키
    - 개인키: 나만 가지고 알고 있어야 하는 키
    
    - 공개키 암호화: 공개키로 암호화를 하면 개인키로만 복호화할 수 있다. -> 개인키는 나만 가지고 있으므로, 나만 볼 수 있다.
    - 개인키 암호화: 개인키로 암호화하면 공개키로만 복호화할 수 있다. -> 공개키는 모두에게 공개되어 있으므로, 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다.