## Java 컴파일 과정

---

JVM: 자바를 실행시키기 위한 가상 컴퓨터, Java Virtual Machine

- 자바는 OS에 종속적이지 않다
- 따라서 OS 위에서 Java를 실행시키기 위한 가상 컴퓨터가 필요
- Java와 OS 사이의 중개자 역할을 하는 스택 기반의 가상머신 (↔ 레지스터 기반)

**자바프로그램의 실행과정**

1. 개발자가 자바 소스코드를 작성( .java )하고 자바 컴파일러를 통해 소스파일을 컴파일
    1. 자바 컴파일러 **javac** 가 자바 소스코드 **.java** 를 읽고 자바 바이트코드 **.class** 로 변환
    2. 컴파일된 파일인 자바 바이트 코드( .class )는 JVM은 이해할 수 있으나 컴퓨터가 읽을 수 있는 언어는 아님
2. 컴파일 된 바이트 코드를 JVM의 클래스 로더에 전달
3. 프로그램을 실행하면 JVM이 OS로부터 필요한 메모리를 할당 받는다.
4. 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩, 링크하여 JVM의 메모리에 로드

    <aside>
    💡 클래스 로더 세부 동작
    1. 로드: 클래스 파일을 가져와 JVM 메모리에 올림
    2. 검증: 구성이 자바 언어 명세, JVM 명세에 부합하게 작성되었는지 검사
    3. 준비: 클래스가 필요로 하는 메모리 할당
    4. 분석: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
    5. 초기화: 클래스 변수들을 적절한 값으로 초기화

    </aside>

5. 실행 엔진은 JVM 메모리의 바이트 코드들을 명령어 단위로 가져와 실행
    1. 인터프리터
    2. JIT 컴파일러

<img width="575" alt="img1 daumcdn 1" src="https://github.com/user-attachments/assets/b3c144b6-6904-4b5d-a451-37f36c3bcb53">

**JVM 구성**

- 클래스 로더
    - 클래스 파일을 로드하고 링크를 통해 재배치.
    - 런 타임 시 동적으로 jar 파일 내 클래스들을 JVM에 탐재, 사용하지 않는 클래스 메모리에서 삭제
- 실행 (execution) 엔진
    - 자바 바이트 코드를 기계가 실행할 수 있는 형태로 변환
- 인터프리터
    - 바이트 코드를 명령어 단위로 읽어 실행
    - 한 줄씩 읽어 수행하기 때문에 느리다
- JIT 컴파일러
    - 인터프리터의 단점을 보완하기 위해 등장
    - 인터프리터 방식으로 실행 중 바이트코드 전체를 컴파일
    - 이후에는 인터프리터를 사용하지 않고 컴파일된 네이티브 코드로 수행
- 가비지 컬렉터
    - GC를 수행하는 모듈


**런타임 데이터 에리어**
  <img width="575" alt="img1 daumcdn 1" src="https://github.com/user-attachments/assets/a4066ec8-0e80-4e74-a64c-9e3ccce81002">

출처:

- [https://asfirstalways.tistory.com/158](https://asfirstalways.tistory.com/158)