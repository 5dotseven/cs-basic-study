### **Graph**

---

서로 연결되어 있는 정점간의 관계를 표현한 자료 구조

- 정점과 정점들을 연결하는 간선들로 구성되어 있다.
- V = {1, 2, 3, 4} : 정점 4개 1, 2, 3, 4
- E = {(1, 2), (2, 3), (3, 4), (1, 4), (2, 4)} : 정점들의 연결 상태를 표현

**종류**

- 무방향 그래프와 방향 그래프
    - (1, 2) : 무방향 1과 2는 서로 오고 갈 수 있다.
    - <1, 2>: 방향이 있어 1에서 2로만 갈 수 있는 간선을 표현
- 완전 그래프
    - 모든 정점이 서로 연결되어 간선의 개수가 최대인 그래프
    - 정점이 N개인 경우 최대 간선 개수: 무방향 그래프는 n(n-1)/2개, 방향 그래프는 n(n-1)개
- 부분 그래프
    - 원본 그래프에서 일부 간선, 정점을 제외하여 만든 그래프
    - A1이 원본일 경우 A1’과 같은 형태로 표시한다.
- 가중 그래프
    - 간선에 가중치를 준 그래프
    - 간선 사용 시 비용, 최대 이동 가능 횟수 등
- 유향 비순환 그래프
    - 방향 그래프에서 순환하는 사이클이 없는 그래프
- 연결, 비연결 그래프
    - 무방향 그래프에서 모든 간선들에 대한 경로가 존재하는 그래프
    - 같은 조건에서 특정 정점에 대한 경로가 존재하지 않는 경우

**장단점**

- 복잡해 보이는 관계를 보기 쉽고 풀어낼 수 있다.
- 네트워크, 최적화 문제에서 가중치, 최적 경로 등을 쉽게 찾아낼 수 있다.
- 데이터가 커질수록 탐색 비용, 수행 시간이 증가하여 문제가 발생할 수 있다.
- 정점과 간선이 많아질수록 보기 복잡해질 수 있다.

**구현방법**

1. 인접리스트 - 가장 일반적인 방법
    1. 모든 정점을 인접 리스트에 저장, 각 정점에 인접한 정점들을 리스트로 표현
    2. 정점의 번호만 알면 인접한 정점으로 접근이 가능
    3. 모든 간선의 개수를 알고자 할 경우 인접 리스트를 전부 탐색하야하기 때문에 O(N+E)의 시간이 소요
2. 인접 행렬
    1. 그래프의 정점을 2차원 배열로 구현, N개라면 N*N의 배열이 필요
    2. 무방향 그래프는 대칭적 그래프의 형태를 가지게 된다.
    3. 가중치의 경우 0과 1이 아닌 가중치의 값을 저장하며 가중치가 0인 경우와 간선이 없는 경우를 구분하여 구현해야 한다.
    4. 모든 정점들과 간선 정보가 저장되어 있기 대문에 정점간의 연결 조회는 O(1)이 걸린다.
    5. 2차원 배열이기 때문에 인접리스트에 비해 공간 복잡도가 크다.

![graph](./이미지/img1.daumcdn.png)

**DFS, BFS**

- DFS - 깊이 우선 탐색
    - 특정 노드로 시작하여 다음 분기점으로 넘어가기 전에 한 분기점의 끝까지 먼저 탐색
    - 정점을 N, 간선의 수를 E로 둘 때 인접 행렬로 구현한 그래프의 DFS 시간 복잡도는 O(N^2)
    - 인접 리스트의 경우 O(N+E)
- BFS - 너비 우선 탐색
    - 특정 노드로 시작하여 인접한 노드 먼저 탐색해 나가는 방식
    - 정점을 N, 간선의 수를 E로 둘 때 인접 행렬로 구현한 그래프의 BFS 시간 복잡도는 O(N^2)
    - 인접 리스트의 경우 O(N+E)