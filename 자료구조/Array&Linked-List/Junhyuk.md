# 배열

배열은 연속된 메모리 공간에 순차적으로 저장된 데이터 모음

열을 구성하는 각각의 값을 **요소(element)** 라고 하며, 배열에서의 위치를 가리키는 숫자는 **인덱스(index)**라고 합니다.

특징 : 

동일한 데이터 유형을 갖는다.

배열의 접근하는 시간은 BigO(1)로 모두 동일

장점 :

- 인덱스를 이용해 접근하기 때문에 모든 요소에 빠르게 접근할 수 있다.
- 데이터의 공간낭비가 적다.

단점 : 

- 배열을 선언한 후 크기를 변경 할 수 없다.
- 중간에 삽입하거나 데이터를 삭제하는 경우 메모리가 순차적으로 이어져 있기 때문에 불리하다.
- 동적으로 데이터 삽입 삭제가 있는 경우 크기가 미리 정해지는 배열은 불리하다.

배열을 사용하는 경우

- 데이터의 순서가 중요할 때
- 특정 인덱스의 값을 빠르게 읽어야할 때
- 데이터 사이즈가 자주 변하지 않고 요소가 자주 삭제되거나 추가되지 않을때

# 리스트

**순차 리스트 연결 리스트**

순차 리스트는 데이터가 삽입되고 삭제되면 위치를 유지하기 위해 원소들을 욺기는 작업이 필요하다.

연결 리스트는 데이터를 삽입하고 삭제할 때 다음 노드의 주소만 수정하면 되기 때문에 연산이 빠르다

탐색의 경우 순차 리스트는 인덱스의 값을 가지고 있기 때문에 탐색이 빠르며 연결 리스트의 경우 처음부터 다음 리스트에 대한 정보를 탐색해야하기 때문에 느리다.

### Array와 List의 차이점

**삽입**

배열은 삽입하고자 하는 인덱스에 데이터를 덥어쓴다. (크기가 늘어나지 않음)

리스트는 삽입하고자 하는 위치에 데이터를 넣고 데이터들을 한칸씩 뒤로 미룬다(크기가 늘어남)

**삭제**

배열은 인덱스의 데이터를 삭제하면 해당 인덱스는 빈 공간이 된다.

리스트는 인덱스의 데이터를 삭제하면 해당 데이터를 삭제하고 뒤에서부터 한칸씩 앞으로 채운다.

# 연결 리스트(Linked List)

## 연결 리스트(Linked List)란?

연결 리스트(Linked List)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다. 데이터를 담고 있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하게 된다.

## 연결 리스트(Linked List)의 종류

### 단순 연결 리스트(Singly linked list)

단일 연결 리스트(Singly linked list)는 각 노드에 자료 공간과 한 개의 포인터 공간이 있고, 각 노드의 포인터는 다음 노드를 가리킨다.

![image](https://blog.kakaocdn.net/dn/bpxqG0/btrCqm679C3/8kFLWIcEsLvu8Kka72vKz1/img.png)

### 이중 연결 리스트(Doubly linked list)

단순 연결 리스트(Singly Linked List)는 next로 현재 노드에서 다음 노드로 갈 수 있지만 이전 노드로는 갈 수 없습니다. 이러한 단점을 해결하기 위해 노드에 앞 노드의 메모리 주소를 보관하는 포인터 prev를 만들어준 형태를 이중 연결 리스트(Doubly Linked List) 입니다.


![image](https://blog.kakaocdn.net/dn/Cohpq/btrCrOBPLs2/8d1Vs1rFxF21Rtbqq98mp0/img.png)

### 원형 연결 리스트(Circular linked list)

원형 연결 리스트(Circle linked List)란 단순 연결 리스트(Singly Linked List)의 마지막 노드의 포인터가 NULL이 아닌 헤드를 가리키는 형태의 리스트 입니다. 따라서 리스트의 끝이 존재하지 않습니다.


![image](https://blog.kakaocdn.net/dn/baTweJ/btrCqGK19ud/ZAFSrf5ErtkqxXL69MEF91/img.png)

## 연결 리스트(Linked List)의 시간 복잡도

### 접근(Access) 시간 복잡도: O(n)

- 인덱스가 없이 서로의 연결에 의존함으로 순회해아 한다.
- 최악의 경우 시간 복잡도 : O(n)

### 탐색(Find) 시간 복잡도: O(n)

- 배열을 탐색할 때와 같은 방법으로 구한다.
- 최악의 경우 시간 복잡도 : O(n)

### 삽입/삭제(Insertion/Deletion) 시간 복잡도: O(1)

- 삽입, 삭제할 노드의 주변 노드들의 Link만 수정하면 된다.
- 따라서 삽입, 삭제가 실행되는 시간은 특정 값에 비례하지 않고 항상 일정하다.
- 시간 복잡도 : O(1)
- 배열과 다르게 삽입 삭제 후 앞 뒤 노드를 변경해준다.
    - 노드를 탐색하는 과정이 필요할 경우 O(n)의 시간 복잡도가 추가된다.