### Index

- Index 란?
    - **추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조**
    - 데이터베이스에서는 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 **데이터와 데이터의 위치를 포함한 자료구조**를 생성하여 빠르게 원하는 데이터를 조회할 수 있도록 한다.
    - 테이블의 특정 칼럼(Column)에 인덱스를 생성하면, 해당 칼럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 칼럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장
    - 장점
        - 테이블을 조회하는 속도와 그에 따른 성능을 향상할 수 있다.
        - 전반적인 시스템의 부하를 줄일 수 있다.
    - 단점
        - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장 공간이 필요하다.
        - DML
            - INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 데이터들을 다시 정렬을 해야 한다. 
            → 인덱스를 사용하려면 데이터의 변경이 잦은 테이블보다 검색 위주의 테이블에 사용하면 좋다.
- Index 의 자료구조
    - **해시 테이블(Hash Table)**
        
        ![Untitled](https://github.com/5dotseven/cs-basic-study/assets/118906074/798888f4-3810-4222-8465-9fcad2176b6a)
        
        - key와 value를 한 쌍으로 데이터를 저장하는 자료구조
        - (key, value)로 쌍을 표현하며, key값을 이용해 대응되는 value값을 구하는 방식
    - **B+Tree**
        - B-Tree의 단점을 개선시킨 자료구조
        - 기존의 B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야 하므로 비효율적이다.
        - 일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- **Primary index**
    - 기본키를 기반으로 만들어진 인덱스
    - 키는 각 레코드에 대해 고유하며, 레코드 간 1:1 관계
    - 기본 인덱스를 사용하여 데이터를 검색하여 정렬된 순서로 데이터를 저장하기 때문에 효율적
        - **Dense Index**
            - 데이터 파일의 모든 검색 키 값에 대한 인덱스 레코드가 포함
            - 검색 속도가 빨라진다
            - 인덱스 테이블의 레코드 개수는 메인 테이블의 레코드 개수와 같다.
            - 인덱스 레코드 자체를 저장하려면 많은 저장 공간이 필요
        - **Sparse Index**
            - 데이터 파일에서 인덱스 레코드는 일부 항목에 대해서만 나타납니다.
            - 각 항목은 블록을 가리킵니다.
            - 기본 테이블의 각 레코드를 가리키는 대신 간격으로 기본 테이블의 레코드를 가리킵니다.
- **Secondary index**
    - 매핑 크기를 줄이기 위해 다른 수준의 인덱싱이 도입되었습니다.
    - 첫 번째 수준의 매핑 크기가 작아지도록 열에 대한 거대한 범위가 초기에 선택됩니다.
    - 이 후 각 범위는 더 작은 범위로 더 나누어지게 됩니다.
    - 첫 번째 수준의 매핑은 기본 메모리에 저장되므로 주소를 가져오기가 더 빨라지게 됩니다.
    - 두 번째 수준의 매핑과 실제 데이터는 보조 메모리(하드 디스크)에 저장됩니다.
- **Primary Index vs Secondary Index**
1. Primary Index : 기본키를 포함하며, 중복항복을 포함하지 않는 필드의 집합인 인덱스 Secondary Index : Primary Index가 아니며, 중복항목을 포함할 수 있는 인덱스
2. Order
    1. Primary Index는 데이터 블록의 행이 인덱스 키에서 정렬되어야 함
    Secondary Index는 데이터 블록에서 행이 실제로 구성되는 방식에 영향X
3. 인덱스의 수
    1. primary Index : 1개 , secondary Index는 여러개의 인덱스 가능
- **Composite Index(결합 인덱스)**
    - 결합 인데스란 인덱스를 생성할 때 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말한다.
    - 주 용도는 SQL에서 WHERE절의 조건 컬럼이 2개 이상 AND로 연결되어 함께 사용되는 경우에 많이 사용한다.
    - 결합 인덱스를 생성할 때 컬럼 순서는 매우 중요하다.
        - 첫 번째 조건에서 최대한 많은 데이터를 걸러내서 두 번째 조건을 검사하도록 해야 한다.
- Index 의 성능과 고려해야할 사항
    - 인덱스 성능
        - 인덱스는 데이터베이스 메모리를 사용하여 테이블 형태로 저장되므로 개수와 저장 공간은 비례합니다.
        - 인덱스 사용 좋은경우
            - 조회시 자주 사용하고
            - 고유한 값 위주로
            
            인덱스를 사용 안좋은 경우
            
            - Data 중복도가 높은 Column
            - DML이 자주 일어나는 Column
            
    - 인덱스를 효율적으로 설정하기 위해 고려해야 하는 사항
        1. 한 컬럼이 갖고 있는 값의 중복 정도가 낮을 수록 좋다.
        2. INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼일 수록 좋다.
        3. JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼일 수록 좋다.
        4. 인덱스 키의 크기는 되도록 작게 설계되어야 성능에 유리하다.
        5. 분포도가 좁은 범위, 기본키, 조인과 연결 고리가 되는 컬럼을 인덱스로 구성한다.
        6.  단일 인덱스 여러 개 보다 다중 컬럼 인덱스를 구성하는 게 좋다.
        7. 되도록 동등 비교를 사용하는 것이 좋다.
        8.  인덱스를 많이 생성하면 INSERT/DELETE/UPDATE의 성능 저하 원인이 될 수 있다.
        9. 인덱스 생성 시 가장 효율적인 자료형은 정수형 타입이다. 가변적인 크기와 정규화 할 수 없는 데이터는 인덱스 생성 시 비효율적으로 동작한다.