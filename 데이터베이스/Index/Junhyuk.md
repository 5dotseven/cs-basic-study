# Index란

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위해 부여한 값.

인덱스를 활용하면 데이터를 조회해야하는 SELECT,UPDATE,DELETE의 성능이 향상된다.

### Index관리

인덱스가 적용되니 컬럼에 INSERT,UPDATE, DELETE가 수행되면 아래와 같은 연산을 추가적으로 해주어야 한다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가함
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

### **인덱스(index)의 장점과 단점**

- 장점
    - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
    - 전반적인 시스템의 부하를 줄일 수 있다.
- 단점
    - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
    - 인덱스를 관리하기 위해 추가 작업이 필요하다.
    - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
    

### **인덱스의 분류**

1. **클러스터 인덱스**: 테이블의 PK에 적용되는 인덱스

2. **비클러스터 인덱스**: 테이블의 PK 이외의 컬럼에 적용되는 인덱스

3. **유니크 인덱스**: PK는 아니지만 Unique 속성을 가진 컬럼에 적용되는 인덱스 (Nullable할 수도 있다.)

## 인덱스의 자료 구조

### B+Tree 인덱스(탐색에 장점)

가장 많이 사용되는 인덱스의 구조로 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조입니다. B+Tree는 다음과 같은 요소로 구성되어 있습니다.

- **Root node:** 검색 경로의 출발점
- **Leaf node:** 실제 검색할 데이터가 저장된 노드
- **Non-leaf node:** Leaf node까지 가기 위해 다음 경로 노드의 Key 값을 가지고 있는 노드
- **LinkedList:** 부등호를 이용한 순차 검색 연산이 용이하도록 Leaf node들을 LinkedList로 연결

SELECT 쿼리를 날리면 Root node에서 시작하여 Non-Leaf nodes를 거쳐 Leaf node를 검색합니다.

### 해시테이블 인덱스(검색에 장점)

**해시 테이블**은 *(Key, Value)* 구조로 데이터를 관리하며 *해시 함수*를 기반으로 Key 값을 생성하는 자료구조입니다. Key에 해당하는 Value를 찾기 위해 해시 함수를 한 번만 실행하면 된다는 점에서 빠른 연산을 보장합니다.

### 해시 인덱스의 장점

- 트리 내에서 여러 노드를 읽어야만 데이터를 찾을 수 있는 B+Tree보다 검색 속도가 빠르다.
- 데이터에 해시 함수를 적용하여 저장하기 때문에 키 값의 크기가 줄어들어 가용성이 좋다.

### 해시 인덱스의 단점

- **부등호를 이용한 조건 조회가 불가능**하다.

해시 인덱스는 해시 함수를 기반으로 데이터를 검색하기 때문에 데이터를 정렬하지 않습니다. 그러므로 부등호를 사용한 검색 조건에 있어서는 어떤 방법으로도 해시 인덱스를 활용할 수 없습니다.

## 인덱스를 사용할 때 고려해야할 점

**인덱스 테이블**

인덱스는 하나의 테이블을 생성해 값을 저장해놓고 사용한다. 그래서 다른 테이블에 의존적인 새로운 테이블이 하나 생성된다는 점에서 무분별한 인덱스 생성은 오히려 성능 저하를 초래할 수 있다.

**정렬**

인덱스 테이블은 "이진트리 검색"을 사용하기 때문에 기본적으로 정렬되어 있다. 그래서 만약 인덱스 테이블이 참조하는 테이블에서 "삽입", "삭제", "수정"이 자주 일어나게 된다면 인덱스 테이블에서는 데이터를 정렬하면서 삽입, 삭제, 수정이 이루어지기 때문에 전체적인 성능 저하를 초래할 수 있다.
