# JS - Object Prototype
>왜 자바스크립트는 다른 언어처럼 클래스가 아니고 프로토타입인가?

먼저, 프로토타입을 이해하려면 그 반대인 클래스의 기원을 알아야함

프로그래밍은 서양철악이 반영되어있고 서양철학은 이분법적인 세계관을 가지고있슴
- 영혼 / 육체
- 추상적 / 구체적
- 이데아 / 프랙터스

## 플라톤과 이데아, 그리고 클래스 기반 객체지향프로그래밍
`눈앞에 실제로 구체적으로 존재하는 사물이 있다면 반드시 그것의 본질이 존재한다 -> 플라톤의 주장`
의자는 여러가지 형태로 존재함(바퀴달린 의자, 원목의자, 흔들의자) 이러한 수 많은 의자가 실제로 존재한다면 반드시 그 본질적이고 추상적인 `의자`라는 것이 존재하고 이러한 본질 세계를 `이데아`라고하고 현실의 의자는 모두 이데아의 `의자`를 모방한 의자라는 것

이분법적 세계관의 기본이 영어권 사고방식 `관사`를 보면 쉽게 알 수 있음 추상적인 의자를 얘기할때는 그냥 chair라고 쓰지만 현실의 존재하는 의자를 말할때는 the chair, a chair 등을 사용함
- chair: 이데아 존재하는 본질적인, 추상적인 의자, 현실세계 존재 X
- a chair, the chair, chairs: 현실세계에 존재하는 의자

이러한 사고방식이 자연스럽게 녹아든 것이 -> `클래스 기반 객체지향 프로그래밍 언어` 바로 java, C# 등이 여기에 해당 됨

```java
class Chair {
...
}
Chair myChair = new Chair();
```

여기서 레퍼런스 타입이라 불리는 `Chair 클래스`는 이데아에 존재하는 추상적인 개념 즉, 코드상으로는 존재하지만 실제 메모리상에는 존재하지 않는 것(Heap메모리만 실존하는 공간으로 봤을떄) 그렇다면 현실에 존재하게 하려면 어떻게 할까? 바로 `new 키워드`를 사용함 new Chair()를 하는 순간 추상적으로만 존재하던 의자가 메모리라는 현실세계의 구체적으로 존재하게 됨 그리고 이걸 프로그래밍에서 `인스턴스화`라고 함

이러한 클래스 방식의 OOP언어는 플라톤류의 서양철학이 자연스럽게 반영된 것

### 분류(Classification)
이러한 플라톤의 이데아 이론은 그의 제자 아리스토텔레스에 의해서 `분류`란 개념으로 정리됨 따라서 언어에서 class는 여기서 따온걸 알 수 있음
- 개체의 속성이 동일한 경우 개체 그룹이 같은 범주에 속한다. 범주는 정의와 구별의 합이다.

이는 전통적인 클래스기반객체지향 프로그래밍의 아이디어-일반화(generalization) 일치하는걸 볼 수 있음


## 프로토타입(Prototype)
>프로토타입이론은 이 분류라는 개념을 정면으로 반박하여 나온 이론

19세기 비트겐슈타인은 아리스토텔레스의 분류라는 개념을 정면으로 반박함
>공유 속성의 관점에서 정의하기 어려운 개념이 있다(사실상 올바른 분류란 없다) - 비트겐슈타인

이 얘기를 하며 들고온 근거는 바로 게임 일반적인 게임은 승리와 패배가 명확함 따라서 속성이 명확하게 승리, 패배라고 볼 수 있지만 만약 승리와 패배가 없는 게임을 가지고 온다면?
![[스크린샷 2024-08-07 오전 10.05.16.png]]
(이 게임은 빙글빙글 돌다가 다같이 주저앉는 게임 누구도 승리하지 않고 패배하지 않는다)

이처럼 게임에는 공유속성이 없다는 것
- 승리/패배가 없는 게임도 존재
- 숙련도? -> 운빨게임에는 필요가 없음
- 플레이이어 존재 여부? -> 플레이어가 전혀 필요하지 않은 게임도 있음

특히 게임 말고 예술작품 쪽으로 간다면 공통속성을 정의할 수 없는 것들이 점점 많아짐

즉, 좀 더 철학적으로 본다면 `게임, 예술 등의 단어는 결코 속성으로 규정할 수 없는 것`

자바나 C#등으로 개발하다보면 본질적으로 한게를 직멱 할 때 가 있음 바로 최적의 `클래스를 설계하는 것` 속성(property)으로 분류하는 것은 확장성을 고려하면 좋은 방식이 아님 따라서 정답이라 생각했던 설계도 개발을 진행하다보면 다 뒤엎는 경우가 많아짐 그래서 이러한걸 좀더 잘 하기 위해 `도메인기반설계, SOLID, 디자인패턴`으로 최대한 그럴싸한 클레스를 설계하게 되는 것

## 의미사용이론(the use theory of meaning)
>표현은 삶의 흐름 속에서만 의미를 갖는다 - 비트겐슈타인

비트겐슈타인이 일생의 후기에 내놓은 이론 `사용(use)에 의해 의마(meaning)가 결정된다는 이론` 단어의 쓰임새가 곧 의미가 된다라는걸 의미

즉, 단어의 `진정한 본래의미란 존재하지 않고 상황과 맥락에 의해서 결정된다` 라는 주장 그러니 단어의 의미를 백날 분석해봤자 소용이 없다라는 것

비트겐슈타인은 벽돌을 예로 들었음 누눈가 벽돌!! 이라고 소리친다면
- (벽돌이 필요할 때) : 벽돌을 달라
- (벽돌로 보수해야 할 때) : 벽돌을 채우라
- (벽돌이 떨어질 때) : 벽돌을 피해라

이처럼 상황마다 상황이 달라진다 즉 -> `맥락(context)`가 중요

## 가족 유사성(Family Resemblance)
![[스크린샷 2024-08-07 오전 10.26.04.png]]

>비트겐슈타인:  "인간이 현실에서 실제로 대상을 분류할 때 속성(전통적인 분류에서 기준)이 아인 가족 유사성을 통해 분류하게된다."

위 그림처럼 가족이 있을때 이 가족이 모두 공유하는 공통속성은 없음 (갈색머리, 안경, 수업, 큰귀, 큰코 등 등) 하지만 우리는 가족이라고 인식함 이것은 분류방식을 `가족유사성`에 의한 분류를사용하기 때문임

이 근거들이 프로토타임 이론에 근거가됨

## Rosch의 프로토타입 이론
자바스크립트에 프로토타입이 바로 이 이론에서 따온것

비트겐슈타인의 의미사용론, 가족유사성은 1970년대 철학자  Eleanor Rosch에 의해 `프로토타입 이론`으로 정리됨

Rosch는 한 가지 실험을 함
- 실험의 참가자들에게 여러 범주 구성원(사과, 코코넛, 오렌지)의 속성을 적어보세요라고함
- 그리고 각 범주 구성원에 대해 범주의 다른 구성원과 공유하는 속성의 개수를 도출
- 사과, 오렌지: 2점(둥글다, 즙이 있다.)
- 코코넛: 1점(둥글다)

점수가 높다 -> 가족유사성이 높다
전통적인 분류에서는 사과, 오렌지, 코코넛은 모두 단순히 과일로 볼 수 있지만 프로토타입에서는 `사과와 오렌지가 가장 전형젹인 무언가 이고` 반면에 `코코넛은 저 구성원들 중에 가장 비 전형적인 무엇가로 볼 수 있음`

이 실험을 통해 로쉬는 인간은 사물을  볼 때 자연스럽게 가장 유사성이 높은 것 순서대로 등급을 매기고 이 형테는 `원형(Prototype)` 이란 주장이 프로토타입이론
![[스크린샷 2024-08-08 오전 9.29.37.png]]

이 이론에 또 한가지 중요한 특징은 `상황(context)`

같은 단어라 할지라도 누가 어떤 상황에서 접했냐에 따라 의미가 달라진다는 것(의미사용이론)

예를 들면 아이가 생각하는 새의 범주에서 "참새"는 명확하게 새에 속함 하지만 펭귄은? 해당 범주에 속하지 못할 수도 있음. 왜냐하면 아이가 생각할 땐 펭귄은 매우 비전형적이기 때문에 따라서 같은 단어여도 어떤 상황(누가, 어디서)접했냐에 따라 범주가 크게 달라진다는 것

따라서 두 가지만 기억하면 된다
- 현실에서 존재하는 것중 가장 좋은 본보기를 원형으로 선택
- 문맥에 따라 '범주' 즉 '의미'가 달라짐.

## 프로토타입 기반 객체지향 프로그래밍
프로토타입 기반 OOP언의 특징
- 개별 객체(instance) 수준에서 메소드와 번수를 추가
- 객체 생성은 일반적으로 복사를 통해 이루어짐
- 확장(extends)은 클래스가 아니라 위임(delegation)
    - 현재 객체가 메세지에 반응하지 못할 때 다른 객체로 메시지를 전달할 수 있게 함 이게 상속의 본질을 지원하는 것
- 개별 객체 수준에서 객체를 수정하고 발전시키는 능력은 `선험적 분류의 필요성을 줄이고 반복적인 프로그래밍 및 디자인 스타일을 정리`'
- 프로토탙입 프로그램밍은 일반적으로 `분류하지 않고 유사성을 활용하도록 선택`

```js
function 참새(){
	this.날개갯수 = 2;
	this.날수있나 = true;
}

const 참새1 = new 참새();

console.log("참새의 날개 갯수 : ", 참새1.날개갯수); // 2

function 닭(){
	this.벼슬 = true;
}

닭.prototype = 참새1; // reference(오른쪽이 인스턴스인 점 주목)|

const 닭1 = new 닭();|

console.log("닭1 날개 : ", 닭1.날개갯수, ", 날수있나? ", 닭1.날수있나); // 2, true
닭1.날수있나 = false;
console.log("다시 물어본다. 닭1은 날 수 있나? :", 닭1.날수있나); // false
// 아래는 고전적인 방식의 프로토타입 연결

function 펭귄(){
	참새.call(this); // copy properties
}
펭귄.prototype = Object.create(참새.prototype); // 프로토타입 연결
const 펭귄1 = new 펭귄();
console.log("펭귄1 날개 : ", 펭귄1.날개갯수, ", 날수있나? ", 펭귄1.날수있나); // 2, true
펭귄1.날수있나 = false;
console.log("다시 물어본다. 펭귄1은 날 수 있나? :", 펭귄1.날수있나); // false|
```

- 날개가 2개, 날수 있는 참새1 이 있슴
- 참새1 을 프로토탑이으로 갖는 닭1이 생김 여기서 주목할 점 `오른쪽이 참새(함수)가 아니라 참새1(인스턴스)`인 점 프로토타입 이론은 이미 존재하는 사물을 통해 범주화한다는 점에서 일치하는걸 볼 수 있음
- 닭의 정의에는 날개갯수가 없지만 2가 출력됨. 프로토타입체인에 의해 참새1의 속성에 첩근을 했기 때문
- 닭1은 날수 없다고 나옴. 닭1은 날 수 없지만 프로토타엡에 해당하는 참새1 은 날 수 있음
    - 닭1과 참새1 프로토타입에서 좀더 멀어진것
    - 같은 속성을 변경해도 프로토타입의 객체의 속성은 변경되지 않는 것

## 자바스크립트 - 어휘적 범위
> 변수의 의미는 그 어휘적인 실행문맥에서의 의미가 된다.

그렇기 때문에 동일범위(실행문맥)의 모든 `선언`을 `참고`(호이스팅)해 의미를 정함

|     |                                                         |
| --- | ------------------------------------------------------- |
|     | // 전역 실행문맥 생성. 전체 정의(name, init) 호이스팅                   |
|     | var name = 'Kai';                                       |
|     | init(); // init 실행문맥 생성. 내부 정의(name, displayName) 호이스팅  |
|     | function init() {                                       |
|     | var name = "Steve";                                     |
|     | function displayName() {                                |
|     | console.log(name); // 현재 실행문맥 내에 정의된게 없으니 outer 로 chain |
|     | // var name = 'troll?'; // 주석 해제되면 호이스팅                 |
|     | }                                                       |
|     | displayName(); // displayName 실행문맥 생성. 내부 정의 호이스팅.      |
|     | }                                                       |

## Reference & Additional Resources
https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42



```js
function Ultra() {}
Ultra.prototype.ultraProp = true;

function Super() {}
Super.prototype = new Ultra();

function Sub() {}
Sub.prototype = new Super();

var o = new Sub();
console.log(o.ultraProp);
```

